/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */
module DIG_DCM_SP #(
    parameter integer CLKFX_DIVIDE = 1,
    parameter integer CLKFX_MULTIPLY = 2,
    parameter real CLKIN_PERIOD = 10.0
)
(
    input cin,
    output cout
);
    // DCM_SP: Digital Clock Manager
    // Spartan-6
    // Xilinx HDL Libraries Guide, version 14.1

    DCM_SP #(
        .CLKDV_DIVIDE(2.0),     // CLKDV divide value
                                // (1.5,2,2.5,3,3.5,4,4.5,5,5.5,6,6.5,7,7.5,8,9,10,11,12,13,14,15,16).
        .CLKFX_DIVIDE(CLKFX_DIVIDE),       // Divide value on CLKFX outputs - D - (1-32)
        .CLKFX_MULTIPLY(CLKFX_MULTIPLY),   // Multiply value on CLKFX outputs - M - (2-32)
        .CLKIN_DIVIDE_BY_2("FALSE"),       // CLKIN divide by two (TRUE/FALSE)
        .CLKIN_PERIOD(CLKIN_PERIOD),       // Input clock period specified in nS
        .CLKOUT_PHASE_SHIFT("NONE"), //Output phase shift (NONE, FIXED, VARIABLE)
        .CLK_FEEDBACK("1X"),         // Feedback source (NONE, 1X, 2X)
        .DESKEW_ADJUST("SYSTEM_SYNCHRONOUS"), // SYSTEM_SYNCHRNOUS or SOURCE_SYNCHRONOUS
        .DFS_FREQUENCY_MODE("LOW"), // Unsupported - Do not change value
        .DLL_FREQUENCY_MODE("LOW"), // Unsupported - Do not change value
        .DSS_MODE("NONE"), // Unsupported - Do not change value
        .DUTY_CYCLE_CORRECTION("TRUE"), // Unsupported - Do not change value
        .FACTORY_JF(16'hc080), // Unsupported - Do not change value
        .PHASE_SHIFT(0), // Amount of fixed phase shift (-255 to 255)
        .STARTUP_WAIT("FALSE") // Delay config DONE until DCM_SP LOCKED (TRUE/FALSE)
    )
    DCM_SP_inst (
        .CLK0(), // 1-bit output: 0 degree clock output
        .CLK180(), // 1-bit output: 180 degree clock output
        .CLK270(), // 1-bit output: 270 degree clock output
        .CLK2X(), // 1-bit output: 2X clock frequency clock output
        .CLK2X180(), // 1-bit output: 2X clock frequency, 180 degree clock output
        .CLK90(), // 1-bit output: 90 degree clock output
        .CLKDV(), // 1-bit output: Divided clock output
        .CLKFX(cout), // 1-bit output: Digital Frequency Synthesizer output (DFS)
        .CLKFX180(), // 1-bit output: 180 degree CLKFX output
        .LOCKED(), // 1-bit output: DCM_SP Lock Output
        .PSDONE(), // 1-bit output: Phase shift done output
        .STATUS(), // 8-bit output: DCM_SP status output
        .CLKFB(), // 1-bit input: Clock feedback input
        .CLKIN(cin), // 1-bit input: Clock input
        .DSSEN(1'b0), // 1-bit input: Unsupported, specify to GND.
        .PSCLK(1'b0), // 1-bit input: Phase shift clock input
        .PSEN(1'b0), // 1-bit input: Phase shift enable
        .PSINCDEC(), // 1-bit input: Phase shift increment/decrement input
        .RST(1'b0) // 1-bit input: Active high reset input
    );
endmodule
module ckDiv(
    input clkin,
    output reg clkout
);

reg [31:0] count, countp;

always @(posedge clkin) begin
    if(count < 500000) begin
    	countp = count + 1;
	clkout = 0;
    end
    else begin
	clkout = 1;
	countp = 0;
    end
end

always @(*) begin
    count = countp;
end

endmodule
module Simon(
    input clk,
    input rst,
    input gen,
    input in1,
    input in2,
    input in3,
    input in4,
    output reg rgen,
    output reg led1,
    output reg led2,
    output reg led3,
    output reg led4,
    output reg win,
    output reg lose
);

reg [7:0] cs;
reg [7:0] ns;

reg [31:0] counter, counterP, timer, timerP, timerOFF, timerOFFP;
reg [2:0] reg1, reg2, reg3, reg4, leds;

always @ (posedge clk) begin
    if(rst)
        cs <= 4'd0;
    else
	cs <= ns;
end

always @ (*) begin
    case(cs)
        7'd0: ns <= 7'd1;
	7'd1: begin
	    if (counter > 32'd160)
		ns <= 8'd2;
	    else if(gen && reg1 == 0)
		ns <= 8'd3;
	    else if(gen && reg2 == 0)
		ns <= 8'd4;
	    else if(gen && reg3 == 0)
		ns <= 8'd5;
	    else if(gen && reg4 == 0)
	    	ns <= 8'd6;
	    else 
		ns <= 8'd1;
	end
	7'd2: ns <= 8'd1;
	7'd3: begin 
	    if(timer > 15)
		ns <= 8'd2;
	    else
		ns <= 8'd3;
	end
	7'd4: begin 
	    if(timer > 15)
		ns <= 8'd2;
	    else
		ns <= 8'd4;
	end
	7'd5: begin 
	    if(timer > 15)
		ns <= 8'd2;
	    else
		ns <= 8'd5;
	end
	7'd6: begin
        if(timer > 15)
            ns <= 8'd7;
        else
            ns <= 8'd6;
	end
    7'd7: ns <= 8'd8;
    7'd8: begin
        if(timer > 15)
            ns <= 7'd9;
	else if(in1 == 1 || in2 == 1 || in3 == 1 || in4 == 1)
	   ns <= 8'd14;
    else
           ns <= 8'd8;
    end
    7'd9: begin
        if(timerOFF > 15) begin
            case(leds)
                4'd1: ns <= 8'd10;
                4'd2: ns <= 8'd11;
                4'd3: ns <= 8'd12;
	            default: ns <= 8'dx;
            endcase
        end
        else    
            ns <= 7'd9;
    end
    7'd10: begin
        if(timer > 15)
            ns <= 7'd9;
        else if(in1 == 1 || in2 == 1 || in3 == 1 || in4 == 1)
	        ns <= 8'd14;
        else 
            ns <= 7'd10;
    end
    7'd11: begin
         if(timer > 15)
            ns <= 7'd9;
        else if(in1 == 1 || in2 == 1 || in3 == 1 || in4 == 1)
	        ns <= 8'd14;
        else 
            ns <= 7'd11;
    end
    7'd12: begin
        if(timer > 15)
            ns <= 7'd13;
        else if(in1 == 1 || in2 == 1 || in3 == 1 || in4 == 1)
	        ns <= 8'd14;
        else 
            ns <= 7'd12;
    end
    7'd13: begin
        if(timerOFF > 15)
            ns <= 7'd7;
        else 
            ns <= 7'd13;
    end
    8'd14: begin
        case(reg1)
            3'd1: begin 
                if(in1 == 1)
                    ns <= 8'd15;
                else
                    ns <= 8'd16;
            end
            3'd2: begin 
                if(in2 == 1)
                    ns <= 8'd15;
                else
                    ns <= 8'd16;
            end
            3'd3: begin 
                if(in3 == 1)
                    ns <= 8'd15;
                else
                    ns <= 8'd16;
            end
            3'd4: begin 
                if(in4 == 1)
                    ns <= 8'd15;
                else
                    ns <= 8'd16;
            end
	    default: ns <= 8'dx;
        endcase
    end
    8'd15: begin
        if(in1 == 0 && in2 == 0 && in3 == 0 && in4 == 0)
            ns <= 8'd17;
        else
            ns <= 8'd15;
    end
    8'd16: ns <= 8'd16;
    8'd17: begin
        if(in1 == 0 && in2 == 0 && in3 == 0 && in4 == 0)
            ns <= 8'd17;
        else
            ns <= 8'd18;
    end
    8'd18: ns <= 8'd19;
    8'd19: begin
        case(reg2)
            3'd1: begin 
                if(in1 == 1 && in2 == 0 && in3 == 0 && in4 == 0)
                    ns <= 8'd20;
                else
                    ns <= 8'd16;
            end
            3'd2: begin 
                if(in1 == 0 && in2 == 1 && in3 == 0 && in4 == 0)
                    ns <= 8'd20;
                else
                    ns <= 8'd16;
            end
            3'd3: begin 
                if(in1 == 0 && in2 == 0 && in3 == 1 && in4 == 0)
                    ns <= 8'd20;
                else
                    ns <= 8'd16;
            end
            3'd4: begin 
                if(in1 == 0 && in2 == 0 && in3 == 0 && in4 == 1)
                    ns <= 8'd20;
                else
                    ns <= 8'd16;
            end
            default: ns <= 8'd17;
        endcase
    end 
    8'd20: begin
        if(in1 == 0 && in2 == 0 && in3 == 0 && in4 == 0)
            ns <= 8'd21;
        else
            ns <= 8'd20;
    end
    8'd21:begin
        if(in1 == 0 && in2 == 0 && in3 == 0 && in4 == 0)
            ns <= 8'd21;
        else
            ns <= 8'd22;
    end
    8'd22: ns <= 8'd23;
    8'd23: begin
        case(reg3)
            3'd1: begin 
                if(in1 == 1 && in2 == 0 && in3 == 0 && in4 == 0)
                    ns <= 8'd24;
                else
                    ns <= 8'd16;
            end
            3'd2: begin 
                if(in1 == 0 && in2 == 1 && in3 == 0 && in4 == 0)
                    ns <= 8'd24;
                else
                    ns <= 8'd16;
            end
            3'd3: begin 
                if(in1 == 0 && in2 == 0 && in3 == 1 && in4 == 0)
                    ns <= 8'd24;
                else
                    ns <= 8'd16;
            end
            3'd4: begin 
                if(in1 == 0 && in2 == 0 && in3 == 0 && in4 == 1)
                    ns <= 8'd24;
                else
                    ns <= 8'd16;
            end
            default: ns <= 8'd17;
        endcase
    end 
    8'd24: begin
        if(in1 == 0 && in2 == 0 && in3 == 0 && in4 == 0)
            ns <= 8'd25;
        else
            ns <= 8'd24;
    end
    8'd25:begin
        if(in1 == 0 && in2 == 0 && in3 == 0 && in4 == 0)
            ns <= 8'd25;
        else
            ns <= 8'd26;
    end
    8'd26: ns <= 8'd27;
    8'd27: begin
        case(reg4)
            3'd1: begin 
                if(in1 == 1 && in2 == 0 && in3 == 0 && in4 == 0)
                    ns <= 8'd28;
                else
                    ns <= 8'd16;
            end
            3'd2: begin 
                if(in1 == 0 && in2 == 1 && in3 == 0 && in4 == 0)
                    ns <= 8'd28;
                else
                    ns <= 8'd16;
            end
            3'd3: begin 
                if(in1 == 0 && in2 == 0 && in3 == 1 && in4 == 0)
                    ns <= 8'd28;
                else
                    ns <= 8'd16;
            end
            3'd4: begin 
                if(in1 == 0 && in2 == 0 && in3 == 0 && in4 == 1)
                    ns <= 8'd28;
                else
                    ns <= 8'd16;
            end
            default: ns <= 8'd17;
        endcase
    end 
    8'd28: ns <= 8'd29;
    8'd29: ns <= 8'd29;
	default:
	    ns <= 7'dx;
    endcase
end

always @ (*) begin
    case(cs)
	7'd0: begin
	    counterP = 4'd0;
	    timerP = 0;
	    reg1 = 0;
	    reg2 = 0;

        reg3 = 0;
	    reg4 = 0;
	    led1 = 0;
	    led2 = 0;
        led3 = 0;
        led4 = 0;
        rgen = 0;
	    win = 0;
	    lose = 0;
	end
	7'd1: begin
	    counterP = counter + 1;
	    rgen = 1;
	end
	7'd2: begin
	    timerP = 4'd0;
	    counterP = 4'd0;
        rgen = 0;
	end
	7'd3: begin 
            timerP = timer + 1;
            reg1 = (counter%4)+1;
            rgen = 1;
	end
    	7'd4: begin 
            timerP = timer + 1;
            reg2 = (counter%4)+1;
            rgen = 1;
	end
        7'd5: begin 
            timerP = timer + 1;
            reg3 = (counter%4)+1;
            rgen = 1;
	end
        7'd6:begin 
            timerP = timer + 1;
            reg4 = (counter%4)+1;
            rgen = 1;
        end
    	7'd7: begin
            rgen = 0;
            timerP = 0;
            leds = 3'd0;
	end
    7'd8: begin
        timerP = timer + 1;
        timerOFFP = 0;
        leds = 3'd1;
        case(reg1)
            4'd1: led1 = 1;
            4'd2: led2 = 1;
            4'd3: led3 = 1;
            4'd4: led4 = 1;
        default: led1 = 1;
        endcase
    end
    7'd9: begin
        timerP = 0;
        timerOFFP = timerOFF + 1;
        led1 = 0;
        led2 = 0;
        led3 = 0;
        led4 = 0;
    end
    7'd10: begin
        timerP = timer + 1;
        timerOFFP = 0;
        leds = 3'd2;
        case(reg2)
            4'd1: led1 = 1;
            4'd2: led2 = 1;
            4'd3: led3 = 1;
            4'd4: led4 = 1;
        default: led1 = 1;
        endcase
    end
    7'd11: begin
        timerP = timer + 1;
        timerOFFP = 0;
        leds = 3'd3;
        case(reg3)
            4'd1: led1 = 1;
            4'd2: led2 = 1;
            4'd3: led3 = 1;
            4'd4: led4 = 1;
        default: led1 = 1;
        endcase
    end
    7'd12: begin
        timerP = timer + 1;
        timerOFFP = 0;
        case(reg4)
        4'd1: led1 = 1;
        4'd2: led2 = 1;
        4'd3: led3 = 1;
        4'd4: led4 = 1;
        default: led1 = 1;
        endcase
    end
    7'd13: begin
        timerOFFP = timerOFF + 1;
	    rgen = 1;
        led1 = 0;
        led2 = 0;
        led3 = 0;
        led4 = 0;
    end
    8'd14: begin
    rgen = 0;
    timerP = 0;
    end
    8'd15: begin
        case(reg1)
            4'd1: led1 = 1;
            4'd2: led2 = 1;
            4'd3: led3 = 1;
            4'd4: led4 = 1;
	    default: led1 = 1;
	endcase
    end
    8'd16: lose = 1;
    8'd18: begin
        led1 = 0;
        led2 = 0;
        led3 = 0;
        led4 = 0;
    end
    8'd20:begin
        case(reg2)
            4'd1: led1 = 1;
            4'd2: led2 = 1;
            4'd3: led3 = 1;
            4'd4: led4 = 1;
	    default: led1 = 1;
	    endcase
    end
    8'd23:begin
        led1 = 0;
        led2 = 0;
        led3 = 0;
        led4 = 0;
    end
    8'd24:begin
        case(reg3)
            4'd1: led1 = 1;
            4'd2: led2 = 1;
            4'd3: led3 = 1;
            4'd4: led4 = 1;
	    default: led1 = 1;
	    endcase
    end
    8'd27:begin
        case(reg4)
            4'd1: led1 = 1;
            4'd2: led2 = 1;
            4'd3: led3 = 1;
            4'd4: led4 = 1;
	    default: led1 = 1;
	    endcase
    end
    8'd29: begin 
	win = 1;
        led1 = 1;
	led2 = 1;
	led3 = 1;
	led4 = 1;
    end
    default: led1 = 1;
   endcase
end

always @ (posedge clk) begin
    counter = counterP;
    timer = timerP;
    timerOFF = timerOFFP;
end

endmodule

module DIG_Counter_Nbit
#(
    parameter Bits = 2
)
(
    output [(Bits-1):0] out,
    output ovf,
    input C,
    input en,
    input clr
);
    reg [(Bits-1):0] count;

    always @ (posedge C) begin
        if (clr)
          count <= 'h0;
        else if (en)
          count <= count + 1'b1;
    end

    assign out = count;
    assign ovf = en? &count : 1'b0;

    initial begin
        count = 'h0;
    end
endmodule

module NoteSelector
(
    input cdo,
    input cre,
    input cmi,
    input cfa,
    input csol,
    input cla,
    input bdo,
    input bre,
    input bmi,
    input bfa,
    input bsol,
    input bla,
    output reg cout,
    output eni
);

  assign eni = bdo | bre | bmi | bfa | bsol | bla;
  always @ (*) begin
       cout = 1'b0;
       if (bdo) begin
          cout = cdo;
       end
       else if(bre) begin
          cout = cre;
       end
       else if(bmi) begin
          cout = cmi;
       end
       else if(bfa) begin
          cout = cfa;
       end
       else if(bsol) begin
          cout = csol;
       end
       else if(bla) begin
          cout = cla;
       end
  end

endmodule

module CompUnsigned #(
    parameter Bits = 1
)
(
    input [(Bits -1):0] a,
    input [(Bits -1):0] b,
    output \> ,
    output \= ,
    output \<
);
    assign \> = a > b;
    assign \= = a == b;
    assign \< = a < b;
endmodule

module DIG_ROM_32X4 (
    input [4:0] A,
    input sel,
    output reg [3:0] D
);
    reg [3:0] my_rom [0:31];

    always @ (*) begin
        if (~sel)
            D = 4'hz;
        else
            D = my_rom[A];
    end

    initial begin
        my_rom[0] = 4'h8;
        my_rom[1] = 4'h9;
        my_rom[2] = 4'ha;
        my_rom[3] = 4'hc;
        my_rom[4] = 4'hd;
        my_rom[5] = 4'he;
        my_rom[6] = 4'hf;
        my_rom[7] = 4'hf;
        my_rom[8] = 4'hf;
        my_rom[9] = 4'hf;
        my_rom[10] = 4'he;
        my_rom[11] = 4'hd;
        my_rom[12] = 4'hc;
        my_rom[13] = 4'hb;
        my_rom[14] = 4'ha;
        my_rom[15] = 4'h8;
        my_rom[16] = 4'h7;
        my_rom[17] = 4'h5;
        my_rom[18] = 4'h4;
        my_rom[19] = 4'h3;
        my_rom[20] = 4'h2;
        my_rom[21] = 4'h1;
        my_rom[22] = 4'h0;
        my_rom[23] = 4'h0;
        my_rom[24] = 4'h0;
        my_rom[25] = 4'h0;
        my_rom[26] = 4'h1;
        my_rom[27] = 4'h2;
        my_rom[28] = 4'h3;
        my_rom[29] = 4'h5;
        my_rom[30] = 4'h6;
        my_rom[31] = 4'h8;
    end
endmodule


module simondicefinal (
  input rst,
  input clk,
  input gen,
  input in1,
  input in2,
  input in3,
  input in4,
  output rgen,
  output led1,
  output led2,
  output led3,
  output led4,
  output win,
  output lose,
  output [3:0] oute // sonido

);
  wire s0;
  wire s1;
  wire s2;
  wire do;
  wire re;
  wire mi;
  wire fa;
  wire win_temp;
  wire lose_temp;
  wire s3;
  wire [4:0] s4;
  wire eni;
  wire cout;
  wire clk_divdo;
  wire [31:0] s5;
  wire clk_divre;
  wire [31:0] s6;
  wire clk_divmi;
  wire [31:0] s7;
  wire clk_divfa;
  wire [31:0] s8;
  wire clk_divsol;
  wire [31:0] s9;
  wire clk_divla;
  wire [31:0] s10;
  assign s1 = ~ rst;
  assign s2 = ~ gen;
  assign do = ~ in1;
  assign re = ~ in2;
  assign mi = ~ in3;
  assign fa = ~ in4;
  DIG_DCM_SP #(
    .CLKFX_DIVIDE(2),
    .CLKFX_MULTIPLY(2),
    .CLKIN_PERIOD(83.33)
  )
  DIG_DCM_SP_i0 (
    .cin( clk ),
    .cout( s3 )
  );
  // ckDiv
  ckDiv ckDiv_i1 (
    .clkin( s3 ),
    .clkout( s0 )
  );
  // Simon
  Simon Simon_i2 (
    .clk( s0 ),
    .rst( s1 ),
    .gen( s2 ),
    .in1( do ),
    .in2( re ),
    .in3( mi ),
    .in4( fa ),
    .rgen( rgen ),
    .led1( led1 ),
    .led2( led2 ),
    .led3( led3 ),
    .led4( led4 ),
    .win( win_temp ),
    .lose( lose_temp )
  );
  DIG_Counter_Nbit #(
    .Bits(32)
  )
  DIG_Counter_Nbit_i3 (
    .en( 1'b1 ),
    .C( s0 ),
    .clr( clk_divdo ),
    .out( s5 )
  );
  DIG_Counter_Nbit #(
    .Bits(32)
  )
  DIG_Counter_Nbit_i4 (
    .en( 1'b1 ),
    .C( s0 ),
    .clr( clk_divre ),
    .out( s6 )
  );
  DIG_Counter_Nbit #(
    .Bits(32)
  )
  DIG_Counter_Nbit_i5 (
    .en( 1'b1 ),
    .C( s0 ),
    .clr( clk_divmi ),
    .out( s7 )
  );
  DIG_Counter_Nbit #(
    .Bits(32)
  )
  DIG_Counter_Nbit_i6 (
    .en( 1'b1 ),
    .C( s0 ),
    .clr( clk_divfa ),
    .out( s8 )
  );
  DIG_Counter_Nbit #(
    .Bits(32)
  )
  DIG_Counter_Nbit_i7 (
    .en( 1'b1 ),
    .C( s0 ),
    .clr( clk_divsol ),
    .out( s9 )
  );
  DIG_Counter_Nbit #(
    .Bits(32)
  )
  DIG_Counter_Nbit_i8 (
    .en( 1'b1 ),
    .C( s0 ),
    .clr( clk_divla ),
    .out( s10 )
  );
  // NoteSelector
  NoteSelector NoteSelector_i9 (
    .cdo( clk_divdo ),
    .cre( clk_divre ),
    .cmi( clk_divmi ),
    .cfa( clk_divfa ),
    .csol( clk_divsol ),
    .cla( clk_divla ),
    .bdo( do ),
    .bre( re ),
    .bmi( mi ),
    .bfa( fa ),
    .bsol( win_temp ),
    .bla( lose_temp ),
    .cout( cout ),
    .eni( eni )
  );
  DIG_Counter_Nbit #(
    .Bits(5)
  )
  DIG_Counter_Nbit_i10 (
    .en( eni ),
    .C( cout ),
    .clr( 1'b0 ),
    .out( s4 )
  );
  CompUnsigned #(
    .Bits(32)
  )
  CompUnsigned_i11 (
    .a( 32'b1011101010100 ),
    .b( s5 ),
    .\= ( clk_divdo )
  );
  CompUnsigned #(
    .Bits(32)
  )
  CompUnsigned_i12 (
    .a( 32'b1001001011011 ),
    .b( s6 ),
    .\= ( clk_divre )
  );
  CompUnsigned #(
    .Bits(32)
  )
  CompUnsigned_i13 (
    .a( 32'b1001010000100 ),
    .b( s7 ),
    .\= ( clk_divmi )
  );
  CompUnsigned #(
    .Bits(32)
  )
  CompUnsigned_i14 (
    .a( 32'b1000101111010 ),
    .b( s8 ),
    .\= ( clk_divfa )
  );
  CompUnsigned #(
    .Bits(32)
  )
  CompUnsigned_i15 (
    .a( 32'b111110010010 ),
    .b( s9 ),
    .\= ( clk_divsol )
  );
  CompUnsigned #(
    .Bits(32)
  )
  CompUnsigned_i16 (
    .a( 32'b110111011111 ),
    .b( s10 ),
    .\= ( clk_divla )
  );
  DIG_ROM_32X4 DIG_ROM_32X4_i17 (
    .A( s4 ),
    .sel( 1'b1 ),
    .D( oute )
  );
  assign win = win_temp;
  assign lose = lose_temp;
endmodule
